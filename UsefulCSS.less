/*=================================================================================
 * Useful CSS With Less
 *
 *================================================================================= */


/*
	The opacity property specifies the opacity/transparency of an element,
	For stupid IE (IE8 and earlier) use filter:alpha(opacity=x).

	Note: For supporting IE9, Add the following code to your HTML page in order to override filter property.
	<!--[if gte IE 9]>
	  <style type="text/css">
		* {
		  filter: none !important;
		}
	  </style>
	<![endif]-->
*/
.opacity(@opacity) {
	@percent: @opacity*100;
	opacity: @opacity;
	filter: alpha(opacity=@percent);
	zoom: 1;  /* Fix for IE7*/
}

/*
	The CSS border-radius property defines the radius of an element's corners.
		▸ If one value is set, this radius applies to all 4 corners.
		▸ If two values are set, the first applies to <top-left> and <bottom-right> corner, the second applies to <top-right> and <bottom-left> corner.
		▸ Three values: the first applies to <top-left> corner, and second applies to <top-right> and <bottom-left> corners, and third value applies to <bottom-right> corner
		▸ Four values apply to the <top-left>, <top-right>, <bottom-right>, <bottom-left> corner in that order.

	Note: If you would like to use elliptical border-radius, set @elliptical.

	Example:
	  .border-radius(150px 150px 150px 150px, 75px 75px 75px 75px);

	Output:
	  div.test {
		-webkit-border-radius: 150px 150px 150px 150px / 75px 75px 75px 75px;
		-moz-border-radius: 150px 150px 150px 150px / 75px 75px 75px 75px;
		border-radius: 150px 150px 150px 150px / 75px 75px 75px 75px;
	  }
*/
.border-radius(@radius; @elliptical:undefined) {
	& when (@elliptical = undefined) {
		-webkit-border-radius: @radius;
		-moz-border-radius: @radius;
		border-radius: @radius;
	}
	& when not(@elliptical = undefined) {
		-webkit-border-radius: @radius e('/') @elliptical;
		-moz-border-radius: @radius e('/') @elliptical;
		border-radius: @radius e('/') @elliptical;
	}
}

/*
	The border-image property allows you to specify an image to be used as the border around an element.
	The border-image property is a shorthand property for:
		▸ border-image-source
		▸ border-image-slice
		▸ border-image-width
		▸ border-image-outset
		▸ border-image-repeat.

	Example:
		.border-image(url(border.png) 30% stretch);

	Output:
		div.test {
			-webkit-border-image: url(border.png) 30% stretch;
			-moz-border-image: url(border.png) 30% stretch;
			-o-border-image: url(border.png) 30% stretch;
			border-image: url(border.png) 30% stretch;
		}

	Syntax:
		border-image: source | slice | width | outset | repeat
*/
.border-image(...){
	-webkit-border-image:@arguments;
	-moz-border-image:@arguments;
	-o-border-image:@arguments;
	border-image:@arguments;
}

/*
	The box-sizing property defines how the width and height of an element are calculated: should they include padding and borders, or not.

	Syntax :
		box-sizing: content-box | border-box
*/
.box-sizing(@value){
	-webkit-box-sizing:@value;
	-moz-box-sizing:@value;
	box-sizing:@value;
}

/*
	The text-shadow property adds shadow to text.
	text-shadow syntax: <horizontal-shadow> <vertical-shadow> <blur> <color>;
	The text-shadow property attaches one or more shadows to a text.

	Note: If you would like to use more shadows to a text, Don't forget to use semicolon at the end of mixin.
		  Because the semicolon in the mixin call is very important. If it is omitted, the comma between the two parameters will be deleted which ends up in an invalid css rule.

	  Example:
		  .text-shadow(0 0 3px #FF0000, 0 0 5px red;);
												   ↧
									 This semicolon is important!

	  Output:
		  p.text-test {
			text-shadow: 0 0 3px #FF0000, 0 0 5px red;
		  }
*/
.text-shadow(...) {
	text-shadow: @arguments;
}

/*
	The box-shadow CSS property is used to add shadow effects around an element's frame.
	box-shadow syntax: <horizontal-offset> <vertical-offset> <blur> <spread> <color>;
	The box-shadow property attaches one or more shadows to an element.

	Note: If you would like to use more shadows to an element, Don't forget to use semicolon at the end of mixin.
		  Because the semicolon in the mixin call is very important. If it is omitted, the comma between the two parameters will be deleted which ends up in an invalid css rule.

		Example:
			.box-shadow(5px 5px 8px blue, 10px 10px 8px red, 15px 15px 8px green;);
																				↧
																	 This semicolon is important!

		Output:
			div.box-test {
				-webkit-box-shadow: 5px 5px 8px blue, 10px 10px 8px red, 15px 15px 8px green;
				-moz-box-shadow: 5px 5px 8px blue, 10px 10px 8px red, 15px 15px 8px green;
				box-shadow: 5px 5px 8px blue, 10px 10px 8px red, 15px 15px 8px green;
			}
*/
.box-shadow(...) {
	-webkit-box-shadow: @arguments;
	-moz-box-shadow: @arguments;
	box-shadow: @arguments;
}

/*
	The CSS @font-face Rule
	Web fonts allow Web designers to use fonts that are not installed on the user's computer.
	When you have found/bought the font you wish to use, just include the font file on your web server, and it will be automatically downloaded to the user when needed.
	Your "own" fonts are defined within the CSS @font-face rule.

	Information about fonts suffix and browsers support:
		*.woff        ==> Pretty Modern Browsers [FF3.6+, IE9, Chrome6+, Saf5.1+]
		*.woff2       ==> Super Modern Browsers [FF39+,Chrome36+, Opera24+]
		*.eot         ==> IE9 Compat Modes
		*.eot?#iefix  ==> Only IE6-8
		*.ttf         ==> Safari, Android, iOS
		*.svg         ==> Old iOS

	Variable:
		@font-path:          ==> Enter your font location. Default: "../fonts";
		@font-family-name:   ==> Use this variable for the font-family property. [e.g: roboto]
		@font-name:          ==> Write the font name without the suffix. [e.g: roboto-bold]
		@font-style:         ==> normal | italic | oblique. Default: normal;
		@font-weight:        ==> normal | bold | bolder | lighter | number[e.g: 100,200,300,...,900]. Default: normal;
		@woff:               ==> Set value "woff" to show woff font. IF set this value "all", shows all font suffix. e.g: woff,woff2,ttf and etc.
		@woff2:              ==> Set value "woff2" to show woff2 font. IF you want to not show "woff2", set NULL;
		@ttf:                ==> Set value "ttf" to show ttf font. IF you want to not show "ttf", set NULL;
		@eot:                ==> Set value "eot" to show eot font. IF you want to not show "eot", set NULL;
		@svg:                ==> Set value "svg" to show svg font. IF you want to not show "svg", set NULL;


	Examples and Outputs:
		.font-face(Roboto, roboto-bold, normal, bold, "all");

			@font-face {
				font-family: "roboto";
				font-style: normal;
				font-weight: normal;
				src: local('roboto'),
					 local('roboto-normal'),
					 url('../fonts/roboto-normal.woff') format('woff'),
					 url('../fonts/roboto-normal.woff2') format('woff2'),
					 url('../fonts/roboto-normal.ttf') format('truetype'),
					 url('../fonts/roboto-normal.eot'),
					 url('../fonts/roboto-normal.eot?#iefix') format('embedded-opentype'),
					 url('../fonts/roboto-normal.svg#roboto-normal') format('svg');
			}



		.font-face(Roboto, roboto-bold, normal, bold, "woff", Null, "ttf");

			@font-face {
				font-family: "Roboto";
				font-style: normal;
				font-weight: bold;
				src: local('Roboto'),
					 local('roboto-bold'),
					 url('../fonts/roboto-bold.woff') format('woff'),
					 url('../fonts/roboto-bold.ttf') format('truetype');
			}



		.font-face(Roboto, roboto-bold, normal, bold, NULL, "woff2", "ttf", NULL, "svg");

			@font-face {
				font-family: "Roboto";
				font-style: normal;
				font-weight: bold;
				src: local('Roboto'),
					 local('roboto-bold'),
					 url('../fonts/roboto-bold.woff2') format('woff2'),
					 url('../fonts/roboto-bold.ttf') format('truetype'),
					 url('../fonts/roboto-bold.svg#roboto-bold') format('svg');
			}


	In brief and at a glance:
		.font-face(@font-family-name; @font-name; @font-style; @font-weight; @woff; @woff2; @ttf; @eot; @svg);
*/
@font-path: "../fonts";
.font-face(@font-family-name: @font-name; @font-name; @font-style: normal; @font-weight: normal; @woff: "woff"; @woff2: NULL; @ttf: NULL; @eot: NULL; @svg: NULL) {
	@font-face {
		font-family: "@{font-family-name}";
		font-style: @font-style;
		font-weight: @font-weight;
		src+: local('@{font-family-name}'),local('@{font-name}');

		&when(@woff = "woff") or (@woff = woff){
			src+: url('@{font-path}/@{font-name}.woff') format('woff');
		}
		&when(@woff2 = "woff2") or (@woff2 = woff2){
			src+: url('@{font-path}/@{font-name}.woff2') format('woff2');
		}
		&when(@ttf = "ttf") or (@ttf = ttf){
			src+: url('@{font-path}/@{font-name}.ttf') format('truetype');
		}
		&when(@eot = "eot") or (@eot = eot){
			src+: url('@{font-path}/@{font-name}.eot'),
				  url('@{font-path}/@{font-name}.eot?#iefix') format('embedded-opentype');
		}
		&when(@svg = "svg") or (@svg = svg){
			src+: url('@{font-path}/@{font-name}.svg#@{font-name}') format('svg');
		}
		&when(@woff = "all") or (@woff = all){
			src+: url('@{font-path}/@{font-name}.woff') format('woff'),
				  url('@{font-path}/@{font-name}.woff2') format('woff2'),
				  url('@{font-path}/@{font-name}.ttf') format('truetype'),
				  url('@{font-path}/@{font-name}.eot'),
				  url('@{font-path}/@{font-name}.eot?#iefix') format('embedded-opentype'),
				  url('@{font-path}/@{font-name}.svg#@{font-name}') format('svg');
		}
	}
}

/*
	CSS Transforms
	CSS transforms allow you to translate, rotate, scale, and skew elements.
	A transformation is an effect that lets an element change shape, size and position.
	CSS supports 2D and 3D transformations.

	When you’re transforming an object with CSS, you have four values to set: <rotate>, <scale>, <skew> and <translate>.
*/
.transform (@rotate: 0deg, @scale: 0, @skew: 0deg, @translate: 0px) {
	-webkit-transform: rotate(unit(@rotate, deg)) scale(@scale) skew(unit(@skew, deg)) translate(@translate);
	-moz-transform: rotate(unit(@rotate, deg)) scale(@scale) skew(unit(@skew, deg)) translate(@translate);
	-o-transform: rotate(unit(@rotate, deg)) scale(@scale) skew(unit(@skew, deg)) translate(@translate);
	-ms-transform: rotate(unit(@rotate, deg)) scale(@scale) skew(unit(@skew, deg)) translate(@translate);
	transform: rotate(unit(@rotate, deg)) scale(@scale) skew(unit(@skew, deg)) translate(@translate);
}

/*
	The transform-origin property allows you to change the position of transformed elements.
	2D transformations can change the x- and y-axis of an element. 3D transformations can also change the z-axis of an element.

	Note: This property must be used together with the transform property.

	Syntax:
		transform-origin: x-axis y-axis z-axis

			▸ Possible values for x-axis: left | center | right | length | %
			▸ Possible values for y-axis: top | center | bottom | length | %
			▸ Possible values for z-axis: length
*/
.transform-origin(@value){
	-webkit-transform-origin:@value;
	-moz-transform-origin:@value;
	-o-transform-origin:@value;
	transform-origin:@value;
}

/*
	The transform-style property specifies how nested elements are rendered in 3D space.
	Note: This property must be used together with the transform property.

	Syntax:
		transform-style: flat | preserve-3d
*/
.transform-style(@style){
	-webkit-transform-style:@style;
	-moz-transform-style:@style;
	transform-style:@style;
}

/*
	The translate() method moves an element from its current position (according to the parameters given for the X-axis and the Y-axis).
	The translate3d() CSS function repositions an element in 3D space
*/
.translate (@x:0; @y:0) {
	@args: ~`"@{arguments}".replace(/[\[\]]/g, '')`;
	-webkit-transform:translate(@args);
	-moz-transform: translate(@args);
	-ms-transform: translate(@args);
	-o-transform:  translate(@args);
	transform:  translate(@args);
}
.translate3d (@x; @y; @z) {
	@args: ~`"@{arguments}".replace(/[\[\]]/g, '')`;
	-webkit-transform:translate3d(@args);
	-moz-transform: translate3d(@args);
	-ms-transform: translate3d(@args);
	-o-transform:  translate3d(@args);
	transform:  translate3d(@args);
}
.translateX (@x) {
	-webkit-transform:translateX(@x);
	-moz-transform: translateX(@x);
	-ms-transform: translateX(@x);
	-o-transform:  translateX(@x);
	transform:  translateX(@x);
}
.translateY (@y) {
	-webkit-transform:translateY(@y);
	-moz-transform: translateY(@y);
	-ms-transform: translateY(@y);
	-o-transform:  translateY(@y);
	transform:  translateY(@y);
}
.translateZ (@z) {
	-webkit-transform:translateZ(@z);
	-moz-transform: translateZ(@z);
	-ms-transform: translateZ(@z);
	-o-transform:  translateZ(@z);
	transform:  translateZ(@z);
}

/*
	  The rotate() method rotates an element clockwise or counter-clockwise according to a given degree.
	  Syntax:
	  	rotate(x, y, z, angle)


	  The rotate3d() CSS function defines a transformation that rotates an element around a fixed axis in 3D space, without deforming it
	  The amount of rotation created by rotate3d() is specified by three <number>s and one <angle>.
	  The <number>s represent the x-, y-, and z-coordinates of the vector denoting the axis of rotation.
	  The <angle> represents the angle of rotation; if positive, the movement will be clockwise; if negative, it will be counter-clockwise.

	  Syntax:
	  	rotate3d(x, y, z, angle)
*/
.rotate (@deg) {
	-webkit-transform: rotate(unit(@deg, deg));
	-moz-transform: rotate(unit(@deg, deg));
	-ms-transform: rotate(unit(@deg, deg));
	-o-transform: rotate(unit(@deg, deg));
	transform: rotate(unit(@deg, deg));
}
.rotate3d (@x; @y; @z; @deg) {
	-webkit-transform: rotate3d(@x, @y, @z, unit(@deg, deg));
	-moz-transform: rotate3d(@x, @y, @z, unit(@deg, deg));
	-ms-transform: rotate3d(@x, @y, @z, unit(@deg, deg));
	-o-transform: rotate3d(@x, @y, @z, unit(@deg, deg));
	transform: rotate3d(@x, @y, @z, unit(@deg, deg));
}
.rotateX (@deg) {
	-webkit-transform: rotateX(unit(@deg, deg));
	-moz-transform: rotateX(unit(@deg, deg));
	-ms-transform: rotateX(unit(@deg, deg));
	-o-transform: rotateX(unit(@deg, deg));
	transform: rotateX(unit(@deg, deg));
}
.rotateY (@deg) {
	-webkit-transform: rotateY(unit(@deg, deg));
	-moz-transform: rotateY(unit(@deg, deg));
	-ms-transform: rotateY(unit(@deg, deg));
	-o-transform: rotateY(unit(@deg, deg));
	transform: rotateY(unit(@deg, deg));
}
.rotateZ (@deg) {
	-webkit-transform: rotateZ(unit(@deg, deg));
	-moz-transform: rotateZ(unit(@deg, deg));
	-ms-transform: rotateZ(unit(@deg, deg));
	-o-transform: rotateZ(unit(@deg, deg));
	transform: rotateZ(unit(@deg, deg));
}

/*
	The scale method increases or decreases the size of an element (according to the parameters given for the width and height).
	The scale function is specified with either one or two values, which represent the amount of scaling to be applied in each direction.
	The scale3d CSS function defines a transformation that resizes an element in 3D space.
*/
.scale (@x:0; @y:@x) {
	@args: ~`"@{arguments}".replace(/[\[\]]/g, '')`;
	-webkit-transform: scale(@args);
	-moz-transform: scale(@args);
	-ms-transform: scale(@args);
	-o-transform: scale(@args);
	transform: scale(@args);
}
.scale3d (@x; @y; @z) {
	@args: ~`"@{arguments}".replace(/[\[\]]/g, '')`;
	-webkit-transform: scale3d(@args);
	-moz-transform: scale3d(@args);
	-ms-transform: scale3d(@args);
	-o-transform: scale3d(@args);
	transform: scale3d(@args);
}
.scaleX (@x) {
	-webkit-transform: scaleX(@x);
	-moz-transform: scaleX(@x);
	-ms-transform: scaleX(@x);
	-o-transform: scaleX(@x);
	transform: scaleX(@x);
}
.scaleY (@y) {
	-webkit-transform: scaleY(@y);
	-moz-transform: scaleY(@y);
	-ms-transform: scaleY(@y);
	-o-transform: scaleY(@y);
	transform: scaleY(@y);
}
.scaleZ (@z) {
	-webkit-transform: scaleY(@z);
	-moz-transform: scaleY(@z);
	-ms-transform: scaleY(@z);
	-o-transform: scaleY(@z);
	transform: scaleY(@z);
}

/*
	The skew() method skews an element along the X and Y-axis by the given angles.
	The skewX() method skews an element along the X-axis by the given angle.
	The skewY() method skews an element along the Y-axis by the given angle.
*/
.skew(@deg:0; @deg2:0) {
	-webkit-transform: skew(unit(@deg, deg), unit(@deg2, deg));
	-moz-transform: skew(unit(@deg, deg), unit(@deg2, deg));
	-ms-transform: skew(unit(@deg, deg), unit(@deg2, deg));
	-o-transform: skew(unit(@deg, deg), unit(@deg2, deg));
	transform: skew(unit(@deg, deg), unit(@deg2, deg));
}
.skewX(@deg){
	-webkit-transform: skewX(unit(@deg, deg));
	-moz-transform: skewX(unit(@deg, deg));
	-ms-transform: skewX(unit(@deg, deg));
	-o-transform: skewX(unit(@deg, deg));
	transform: skewX(unit(@deg, deg));
}
.skewY(@deg){
	-webkit-transform: skewY(unit(@deg, deg));
	-moz-transform: skewY(unit(@deg, deg));
	-ms-transform: skewY(unit(@deg, deg));
	-o-transform: skewY(unit(@deg, deg));
	transform: skewY(unit(@deg, deg));
}

/*
	The matrix() method combines all the 2D transform methods into one.
	The matrix() method take six parameters, containing mathematic functions, which allows you to rotate, scale, move (translate), and skew elements.
	The parameters are as follow: matrix(scaleX(),skewY(),skewX(),scaleY(),translateX(),translateY())

	NOTE: The matrix method take six parameters.
*/
.matrix(...){
	@args: ~`"@{arguments}".replace(/[\[\]]/g, '')`;
	-webkit-transform: matrix(@args);
	-moz-transform: matrix(@args);
	-ms-transform: matrix(@args);
	-o-transform: matrix(@args);
	transform: matrix(@args);
}

/*
  The backface-visibility property defines whether or not the back face of an element should be visible when facing the user.
  The back face of an element is a mirror image of the front face being displayed.
  This property is useful when an element is rotated. It lets you choose if the user should see the back face or not.

  Note: The backface-visibility property is very useful for creating animations like revolving coin or card flipping, where two different images (i.e. front and back side) are blend together to create better 3D rotation effect.

  Syntax:
    backface-visibility: visible|hidden;
*/
.backface-visibility(@value){
	-webkit-backface-visibility:@value;
	-moz-backface-visibility:@value;
	-o-backface-visibility:@value;
	backface-visibility:@value;
}